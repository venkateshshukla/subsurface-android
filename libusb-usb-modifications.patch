From c703d2c2b117cda7d2e2e30071e9790e7979f900 Mon Sep 17 00:00:00 2001
From: Venkatesh Shukla <venkatesh.shukla.eee11@iitbhu.ac.in>
Date: Thu, 10 Jul 2014 19:16:54 +0530
Subject: [PATCH 2/2] Modifications for usage in Android

Android allows access to USB device only via its java based USB API. But as a
workaround for native devices using libusb, one can obtain the file descriptor
of USB device using UsbDeviceConnection.getFileDescriptor() method. This can
then be transferred to native side using JNI. The function libusb_open_fd() must
be used on android and the obtained fd should be passed on. Libusb will use this
file descriptor for all subsequent processing. A libusb_device_handle will be
returned as is usual and can be used for all libusb related stuff.

Signed-off-by: Venkatesh Shukla <venkatesh.shukla.eee11@iitbhu.ac.in>
---
 libusb/core.c           | 69 +++++++++++++++++++++++++++++++++++++++++++++++++
 libusb/libusb.h         |  2 ++
 libusb/libusbi.h        |  8 ++++++
 libusb/os/linux_usbfs.c | 37 ++++++++++++++++++++++++++
 4 files changed, 116 insertions(+)

diff --git a/libusb/core.c b/libusb/core.c
index 767dcbf..fae8b2c 100644
--- a/libusb/core.c
+++ b/libusb/core.c
@@ -987,6 +987,75 @@ int API_EXPORTED libusb_open(libusb_device *dev,
 }
 
 /** \ingroup dev
+ * This function is for usage on android.
+ * Obtain the USB file descriptor from android using its USB API. Use it to
+ * obtain a libusb_device_handle. The handle allows you to perform
+ * I/O on the device in question.
+ *
+ * Internally, this function adds a reference to the device and makes it
+ * available to you through libusb_get_device(). This reference is removed
+ * during libusb_close().
+ *
+ * This is a non-blocking function; no requests are sent over the bus.
+ *
+ * \param dev the device to open
+ * \param handle output location for the returned device handle pointer. Only
+ * populated when the return code is 0.
+ * \returns 0 on success
+ * \returns LIBUSB_ERROR_NO_MEM on memory allocation failure
+ * \returns LIBUSB_ERROR_ACCESS if the user has insufficient permissions
+ * \returns LIBUSB_ERROR_NO_DEVICE if the device has been disconnected
+ * \returns another LIBUSB_ERROR code on other failure
+ */
+int API_EXPORTED libusb_open_fd(libusb_device *dev,
+	libusb_device_handle **handle, int fd)
+{
+	struct libusb_context *ctx = DEVICE_CTX(dev);
+	struct libusb_device_handle *_handle;
+	size_t priv_size = usbi_backend->device_handle_priv_size;
+	int r;
+	usbi_dbg("open %d.%d", dev->bus_number, dev->device_address);
+
+	_handle = malloc(sizeof(*_handle) + priv_size);
+	if (!_handle)
+		return LIBUSB_ERROR_NO_MEM;
+
+	r = usbi_mutex_init(&_handle->lock, NULL);
+	if (r) {
+		free(_handle);
+		return LIBUSB_ERROR_OTHER;
+	}
+
+	_handle->dev = libusb_ref_device(dev);
+	_handle->claimed_interfaces = 0;
+	memset(&_handle->os_priv, 0, priv_size);
+
+	r = usbi_backend->open_fd(_handle, fd);
+	if (r < 0) {
+		usbi_dbg("open %d.%d returns %d", dev->bus_number, dev->device_address, r);
+		libusb_unref_device(dev);
+		usbi_mutex_destroy(&_handle->lock);
+		free(_handle);
+		return r;
+	}
+
+	usbi_mutex_lock(&ctx->open_devs_lock);
+	list_add(&_handle->list, &ctx->open_devs);
+	usbi_mutex_unlock(&ctx->open_devs_lock);
+	*handle = _handle;
+
+	/* At this point, we want to interrupt any existing event handlers so
+	 * that they realise the addition of the new device's poll fd. One
+	 * example when this is desirable is if the user is running a separate
+	 * dedicated libusb events handling thread, which is running with a long
+	 * or infinite timeout. We want to interrupt that iteration of the loop,
+	 * so that it picks up the new fd, and then continues. */
+	usbi_fd_notification(ctx);
+
+	return 0;
+}
+
+/** \ingroup dev
  * Convenience function for finding a device with a particular
  * <tt>idVendor</tt>/<tt>idProduct</tt> combination. This function is intended
  * for those scenarios where you are using libusb to knock up a quick test
diff --git a/libusb/libusb.h b/libusb/libusb.h
index 044012b..dee6285 100644
--- a/libusb/libusb.h
+++ b/libusb/libusb.h
@@ -984,6 +984,8 @@ int LIBUSB_CALL libusb_get_max_iso_packet_size(libusb_device *dev,
 	unsigned char endpoint);
 
 int LIBUSB_CALL libusb_open(libusb_device *dev, libusb_device_handle **handle);
+int LIBUSB_CALL libusb_open_fd(libusb_device *dev, libusb_device_handle **handle,
+	int fd);
 void LIBUSB_CALL libusb_close(libusb_device_handle *dev_handle);
 libusb_device * LIBUSB_CALL libusb_get_device(libusb_device_handle *dev_handle);
 
diff --git a/libusb/libusbi.h b/libusb/libusbi.h
index 3b602d2..0b0857e 100644
--- a/libusb/libusbi.h
+++ b/libusb/libusbi.h
@@ -568,6 +568,14 @@ struct usbi_os_backend {
 	 */
 	int (*open)(struct libusb_device_handle *handle);
 
+	/*
+	 *  Using Android USB API, obtain the file descriptor of the usb device.
+	 *  Open the device using the obtained file descriptor. File descriptor
+	 *  is substitited as such without trying to open the usb device again.
+	 *  This function is for usage on android.
+	 */
+	int (*open_fd)(struct libusb_device_handle *handle, int fd);
+
 	/* Close a device such that the handle cannot be used again. Your backend
 	 * should destroy any resources that were allocated in the open path.
 	 * This may also be a good place to call usbi_remove_pollfd() to inform
diff --git a/libusb/os/linux_usbfs.c b/libusb/os/linux_usbfs.c
index 0717fa0..d98d6e9 100644
--- a/libusb/os/linux_usbfs.c
+++ b/libusb/os/linux_usbfs.c
@@ -1240,6 +1240,37 @@ static int op_open(struct libusb_device_handle *handle)
 	return usbi_add_pollfd(HANDLE_CTX(handle), hpriv->fd, POLLOUT);
 }
 
+#ifdef __ANDROID__
+static int op_open_fd(struct libusb_device_handle *handle, int fd)
+{
+	struct linux_device_handle_priv *hpriv = _device_handle_priv(handle);
+	char filename[PATH_MAX];
+
+	_get_usbfs_path(handle->dev, filename);
+	usbi_dbg("opening %s", filename);
+	hpriv->fd = fd;
+	if (hpriv->fd < 0) {
+		if (errno == EACCES) {
+			usbi_err(HANDLE_CTX(handle), "libusb couldn't open USB device %s: "
+				"Permission denied.", filename);
+			usbi_err(HANDLE_CTX(handle),
+				"libusb requires write access to USB device nodes.");
+			return LIBUSB_ERROR_ACCESS;
+		} else if (errno == ENOENT) {
+			usbi_err(HANDLE_CTX(handle), "libusb couldn't open USB device %s: "
+				"No such file or directory.", filename);
+			return LIBUSB_ERROR_NO_DEVICE;
+		} else {
+			usbi_err(HANDLE_CTX(handle),
+				"open failed, code %d errno %d", hpriv->fd, errno);
+			return LIBUSB_ERROR_IO;
+		}
+	}
+
+	return usbi_add_pollfd(HANDLE_CTX(handle), hpriv->fd, POLLOUT);
+}
+#endif
+
 static void op_close(struct libusb_device_handle *dev_handle)
 {
 	int fd = _device_handle_priv(dev_handle)->fd;
@@ -2402,6 +2433,12 @@ const struct usbi_os_backend linux_usbfs_backend = {
 	.get_config_descriptor = op_get_config_descriptor,
 
 	.open = op_open,
+#ifdef __ANDROID__
+	.open_fd = op_open_fd,
+#else
+	.open_fd = NULL,
+#endif
+
 	.close = op_close,
 	.get_configuration = op_get_configuration,
 	.set_configuration = op_set_configuration,
-- 
1.9.3

